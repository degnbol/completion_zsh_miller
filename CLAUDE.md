# Miller Zsh Completion

This directory contains zsh completion for [Miller (mlr)](https://miller.readthedocs.io/).

## Running Tests

```bash
./test/run_tests.zsh
```

## File Structure

- `_mlr` - Generated completion file (do not edit directly)
- `_mlr.templ` - Template for generating `_mlr`
- `_mlr.sh` - Script that generates `_mlr` from template and help files
- `flags.help` - Generated file containing main mlr flags
- `flags.help.sh` - Script that generates `flags.help` from `mlr help flags`
- `verb/` - Directory containing verb-specific options (*.opt files)
- `descs.help` - Verb descriptions
- `verbs.list` - List of verbs
- `help.topics` - Help topic completions
- `table_unjag.sh` - Helper script for parsing help output
- `RUNME.zsh` - Script to regenerate everything
- `test/` - Test suite

## Regenerating Completions

```bash
./RUNME.zsh
# Or manually:
./flags.help.sh  # Regenerate flags.help
./_mlr.sh        # Regenerate _mlr
```

After regenerating, reload in zsh:
```bash
unfunction _mlr 2>/dev/null; rm -f ~/.zcompdump* && exec zsh
```

## Architecture

### Template (`_mlr.templ`)

The template contains:
1. Main `_mlr()` function with `_arguments` call for global flags
2. State handlers (`from_file`, `mlr-tui`) for special completions
3. Helper functions: `_mlr_commands`, `_mlr_files_or_chain`, `_mlr_field_names`

Placeholders replaced by `_mlr.sh`:
- `#FLAGS` - Main mlr flags from `flags.help`
- `#SUBCMDS` - Verb-specific option handling from `verb/*.opt`
- `#DESCS` - Verb descriptions from `descs.help`

### Key Design Decisions

**`_arguments_options=(-S -C)`**
- `-S`: Don't complete options after `--`
- `-C`: Modify curcontext for state actions
- Note: `-s` (option stacking) was intentionally removed as it causes cursor positioning issues

**State-based file completion for `--from`**
```zsh
'--from[...]: :->from_file'
# Instead of:
'--from[...]:filename:_files'
```
Using `_alternative 'files:filename:_files'` in a state handler enables proper substring matching (e.g., `tion.zsh` -> `completion.zsh`). Direct `_files` in `_arguments` doesn't respect the global `matcher-list`.

**Early return for option completion**
```zsh
[[ -z "$line" && "$state" == "mlr-tui" ]] && return ret
```
When completing main flags (before any verb), `$line` is empty. Without this check, the `mlr-tui` state handler runs and manipulates `words`/`CURRENT`, causing cursor positioning issues. The condition also checks for `mlr-tui` state specifically so other states like `from_file` still work.

### Verb Chaining

Miller supports verb chaining with `then` or `+`:
```bash
mlr --csv head -n 5 then cut -f name then sort file.csv
```

The `mlr-tui` state handler detects chain delimiters and resets completion context for each verb segment. **Important:** Chain detection must search `buf_words` (parsed from `LBUFFER`), not `line` from `_arguments`, because `line` includes text after the cursor which would incorrectly detect chain operators typed after the cursor position.

### Field Name Completion

`_mlr_field_names` reads the input file (from `--from` or trailing args), extracts column names using `mlr --ojsonl head -n 1 | jq -r 'keys[]'`, and offers them as completions for flags like `-f`, `-g`.

**Important:** Field name completion does not add any suffix (comma or space). Adding a trailing comma causes silent failures in mlr (e.g., `-f name,` produces wrong results). Users type commas themselves when building multi-field lists.

### Positional Arguments

Some verbs require positional arguments not documented in `--help`. These are added manually in `RUNME.zsh`:

```zsh
# sub/gsub/ssub require old and new pattern args
for verb in sub gsub ssub; do
    echo '1:old:' >> verb/$verb.help.opt
    echo '2:new:' >> verb/$verb.help.opt
done
```

The `_mlr.sh` script detects lines starting with `N:` (e.g., `1:old:`) and passes them through as positional argument specs without escaping.

## Zsh Completion Concepts

### Matcher List (in `~/dotfiles/zsh/completion.zsh`)

```zsh
zstyle ':completion:*' matcher-list \
    'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' \
    'r:|[._-]=* r:|=*' \
    'l:|=* r:|=*'
```
- Case-insensitive matching
- Partial matching at separators
- Substring matching anywhere

### Completer Chain

```zsh
zstyle ':completion:*' completer _expand _complete _match
```
- `_approximate` was removed to prevent typo-tolerant matches (e.g., `--cs` matching `--asv` instead of `--csv`)

## Important: Generated Files

**Do not edit directly:**
- `_mlr` - Generated by `_mlr.sh`
- `flags.help` - Generated by `flags.help.sh`
- `verb/*.help`, `verb/*.desc`, `verb/*.opt` - Generated by `RUNME.zsh`
- `descs.help`, `verbs.list`, `help.topics` - Generated by `RUNME.zsh`

**To add custom completions**, modify the generation scripts:
- `RUNME.zsh` - For verb-specific fixes (e.g., adding `-f` as synonym for `-g` in uniq)
- `flags.help.sh` - For main flag fixes (e.g., `--from` state-based completion)
- `_mlr.sh` - For escaping/formatting issues
- `_mlr.templ` - For structural changes to the completion function

## Common Pitfalls

**Use `LBUFFER` not `BUFFER` when parsing the command line:**
When there's text after the cursor (e.g., `mlr cut -f <TAB> | sed ...`), `BUFFER` contains the entire line including text after cursor, while `LBUFFER` contains only text before cursor. Always use `LBUFFER` for:
- Parsing command line to find input files
- Detecting chain delimiters (`then`, `+`)
- Checking for trailing space to determine if completing a new word
```zsh
# Bad: includes text after cursor, breaks completion
buf_words=("${(z)BUFFER}")
if [[ "$BUFFER" == *" " ]]; then

# Good: only text before cursor
buf_words=("${(z)LBUFFER}")
if [[ "$LBUFFER" == *" " ]]; then
```

**Backticks in descriptions must be escaped:**
In `_mlr.sh`, verb descriptions are double-quoted, so backticks cause command substitution:
```zsh
# Bad: `sub` gets executed as a command
"sub:Like the \`sub\` DSL function"
# Good: backticks escaped
sed 's/`/\\`/g'
```

**Aux commands have `mlr ` prefix in help output:**
`mlr aux-list` outputs commands like `mlr hex`, not just `hex`. Strip the prefix:
```zsh
mlr aux-list | sed 's/^mlr //'
```

**The `rm` command with glob patterns can be dangerous:**
Be careful with patterns like `rm verb/mlr\ *` - shell expansion issues can delete unintended files.

## Troubleshooting

**Completion not updating after changes:**
```bash
unfunction _mlr 2>/dev/null; rm -f ~/.zcompdump* && exec zsh
```

**Debug completion state:**
```zsh
echo "state='$state' LBUFFER='$LBUFFER' line='$line' words='$words' CURRENT=$CURRENT" >> /tmp/debug.txt
```

**Test minimal completion:**
```zsh
unfunction _mlr 2>/dev/null
_mlr() {
    _arguments -S -C \
        '--csv[desc]' \
        '--asv[desc]' \
        && return 0
}
mlr --cs<TAB>
```

**Parse errors in `_mlr`:**
Usually caused by unescaped special characters. Check for:
- Unescaped backticks in double-quoted strings
- Verb names with special characters (hyphens in case labels need quoting)
- Missing escape for `{`, `}`, `'`, `"`

**Square brackets in option descriptions must be escaped:**
Zsh's `_arguments` uses `[description]` syntax, so nested brackets in descriptions cause parse errors:
```zsh
# Bad: nested [0..100] breaks _arguments parsing
"-p[Produce percents [0..100], not fractions [0..1]]"
# Error: _arguments:comparguments:327: invalid option definition

# Good: inner brackets escaped
"-p[Produce percents \[0..100\], not fractions \[0..1\]]"
```
The `escape_inner_brackets` function in `_mlr.sh` handles this automatically using awk to escape `[` and `]` inside the description while preserving the outer delimiters.
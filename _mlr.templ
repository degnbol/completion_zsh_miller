#compdef mlr

# Used _spt as template.


_mlr() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    # -S: don't complete options after --
    # -C: modify curcontext for state actions
    # Note: -s (option stacking) removed as it causes cursor jump issues
    _arguments_options=(-S -C)

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" \
#FLAGS
":: :_mlr_commands" \
"*::: :->mlr-tui" \
&& ret=0
    # Skip mlr-tui state handling if we're completing options (line is empty)
    # but still handle other states like from_file
    [[ -z "$line" && "$state" == "mlr-tui" ]] && return ret
    case $state in
    from_file)
        # Use _alternative for proper substring matching support
        _alternative 'files:filename:_files'
        ;;
    mlr-tui)
        # Parse LBUFFER to detect chains (ignoring text after cursor)
        local -a buf_words verb_words
        buf_words=("${(z)LBUFFER}")

        # Support verb chaining with 'then' or '+'
        # e.g. mlr --csv head -n 5 then cut -f name then sort
        # IMPORTANT: search buf_words (from LBUFFER), not line, to ignore text after cursor
        local -i delim_pos=0
        local -i idx=${#buf_words}
        while (( idx >= 1 )); do
            if [[ "${buf_words[idx]}" == "then" || "${buf_words[idx]}" == "+" ]]; then
                delim_pos=$idx
                break
            fi
            (( idx-- ))
        done

        # Get verb name: use line[1] from _arguments (correctly parsed),
        # but if we found a chain delimiter in LBUFFER, find verb after it
        local verb_name=""
        if (( delim_pos > 0 )); then
            # Find first non-flag word after delimiter in buf_words
            for (( idx=delim_pos+1; idx <= ${#buf_words}; idx++ )); do
                [[ "${buf_words[idx]}" == -* ]] && continue
                verb_name="${buf_words[idx]}"
                break
            done
        else
            # No chain in LBUFFER, use line[1] from _arguments
            verb_name="$line[1]"
        fi

        if [[ -z "$verb_name" ]]; then
            # No verb yet (or right after 'then'/'+'), complete verb names
            _mlr_commands
        else
            local verb_found=0

            # Find verb position and extract verb + its args
            local idx=1
            while (( idx <= ${#buf_words} )); do
                if [[ "$verb_found" -eq 1 ]]; then
                    # After verb, collect all remaining words
                    verb_words+=("${buf_words[idx]}")
                elif [[ "${buf_words[idx]}" == "$verb_name" ]]; then
                    verb_found=1
                    verb_words+=("${buf_words[idx]}")
                fi
                (( idx++ ))
            done

            # Set words and CURRENT for verb completion
            # Only override if we found the verb in LBUFFER
            if (( ${#verb_words} > 0 )); then
                words=("${verb_words[@]}")
                # If LBUFFER ends with space, we're completing a new word
                if [[ "$LBUFFER" == *" " ]]; then
                    words+=("")
                    CURRENT=${#words}
                else
                    CURRENT=${#verb_words}
                fi
            else
                # Fallback to original pattern
                words=($line[1] "${words[@]}")
                (( CURRENT += 1 ))
            fi

            curcontext="${curcontext%:*:*}:mlr-command-$verb_name:"
            case $verb_name in
#SUBCMDS
            esac
        fi
    ;;
esac
}

(( $+functions[_mlr_commands] )) ||
_mlr_commands() {
    local commands; commands=(
#DESCS
    )
    _describe -t commands 'mlr commands' commands "$@"
}

# Complete files and chain keywords (then/+)
(( $+functions[_mlr_files_or_chain] )) ||
_mlr_files_or_chain() {
    _alternative \
        'chain:chain operator:((then\:"chain next verb" +\:"chain next verb"))' \
        'files:filename:_files'
}

# Complete field names from input file
(( $+functions[_mlr_field_names] )) ||
_mlr_field_names() {
    local file=""
    local -a format_flags=()
    local -a buf_words

    # Parse LBUFFER (text before cursor) to ignore trailing pipes/commands
    buf_words=("${(z)LBUFFER}")

    # Find --from argument
    local idx=1
    while (( idx <= ${#buf_words} )); do
        if [[ "${buf_words[idx]}" == "--from" && -n "${buf_words[idx+1]}" ]]; then
            file="${buf_words[idx+1]}"
            break
        fi
        (( idx++ ))
    done

    # If no --from, look for trailing file arguments
    if [[ -z "$file" ]]; then
        for w in "${buf_words[@]}"; do
            [[ -f "$w" ]] && file="$w" && break
        done
    fi

    [[ -z "$file" || ! -f "$file" ]] && return 1

    # Extract input format flags from command line (only before the verb)
    # Stop when we hit a verb (word that doesn't start with -)
    local found_verb=0
    for w in "${buf_words[@]}"; do
        # Skip 'mlr' itself and arguments to flags
        [[ "$w" == "mlr" ]] && continue
        # If word doesn't start with -, it's likely a verb - stop looking for format flags
        [[ "$w" != -* && "$found_verb" -eq 0 && "$w" != "$file" ]] && found_verb=1
        (( found_verb )) && break
        case "$w" in
            --csv|--icsv|-c|--tsv|--itsv|-t|--json|--ijson|--jsonl|--ijsonl|\
            --dkvp|--idkvp|--nidx|--inidx|--pprint|--ipprint|--xtab|--ixtab)
                format_flags+=("$w")
                ;;
            --c2*|--t2*|--j2*|--d2*|--p2*|--x2*)
                format_flags+=("$w")
                ;;
        esac
    done

    # Use mlr to get first record as JSON, then extract keys
    local -a cols
    cols=("${(@f)$(mlr ${format_flags[@]} --ojsonl head -n 1 "$file" 2>/dev/null | jq -r 'keys[]' 2>/dev/null)}")

    [[ ${#cols} -eq 0 ]] && return 1

    # Support comma-separated field names (e.g., -f name,age,<TAB>)
    # compset -P '*,' strips everything up to the last comma
    compset -P '*,'

    _describe -t fields 'field name' cols
}

# Complete field names from join left file (-f option)
# Used for join -l which needs columns from the left file, not the main input
(( $+functions[_mlr_join_left_field_names] )) ||
_mlr_join_left_field_names() {
    local file=""
    local -a format_flags=()
    local -a buf_words

    # Parse LBUFFER (text before cursor) to ignore trailing pipes/commands
    buf_words=("${(z)LBUFFER}")

    # Find -f argument (join's left file)
    local idx=1
    while (( idx <= ${#buf_words} )); do
        if [[ "${buf_words[idx]}" == "-f" && -n "${buf_words[idx+1]}" ]]; then
            file="${buf_words[idx+1]}"
            break
        fi
        (( idx++ ))
    done

    [[ -z "$file" || ! -f "$file" ]] && return 1

    # Extract input format flags from command line (only before the verb)
    local found_verb=0
    for w in "${buf_words[@]}"; do
        [[ "$w" == "mlr" ]] && continue
        [[ "$w" != -* && "$found_verb" -eq 0 && "$w" != "$file" ]] && found_verb=1
        (( found_verb )) && break
        case "$w" in
            --csv|--icsv|-c|--tsv|--itsv|-t|--json|--ijson|--jsonl|--ijsonl|\
            --dkvp|--idkvp|--nidx|--inidx|--pprint|--ipprint|--xtab|--ixtab)
                format_flags+=("$w")
                ;;
            --c2*|--t2*|--j2*|--d2*|--p2*|--x2*)
                format_flags+=("$w")
                ;;
        esac
    done

    # Use mlr to get first record as JSON, then extract keys
    local -a cols
    cols=("${(@f)$(mlr ${format_flags[@]} --ojsonl head -n 1 "$file" 2>/dev/null | jq -r 'keys[]' 2>/dev/null)}")

    [[ ${#cols} -eq 0 ]] && return 1

    compset -P '*,'

    _describe -t fields 'field name' cols
}

_mlr "$@"
